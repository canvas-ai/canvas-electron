'use strict'

// Import necessary libraries
const crypto = require('crypto');

// Define constants
const DOCUMENT_SCHEMA_VERSION = '1.0';
const DOCUMENT_DATA_CHECKSUM_ALGO = 'sha1';
const DOCUMENT_DATA_FORMAT = 'application/json';
const DOCUMENT_DATA_ENCODING = 'utf8';
const DOCUMENT_SCHEMA_TYPE = 'generic';

// Document class
class Document {


    constructor({
        id,
        type,
        version = 1,
        hashes = {},
        meta = {},
        data,
        versions = [],
        schemaVersion = DOCUMENT_SCHEMA_VERSION,
        dataChecksumAlgorithm = DOCUMENT_DATA_CHECKSUM_ALGO,
    }) {

        // Check and set document ID
        if (!id) { throw new Error('Document ID is a mandatory parameter'); }
        this.id = id;

        // Check and set document type
        if (!type) { throw new Error('Document type is a mandatory parameter'); }
        this.type = type;

        // Set meta information
        const now = new Date().toISOString();
        this.meta = {
            created: now,
            modified: now,
            contentType: meta.contentType || DOCUMENT_DATA_FORMAT,
            contentEncoding: meta.contentEncoding || DOCUMENT_DATA_ENCODING,
            source: {},
            ...meta,
        };

        // Verify content type and hash
        if (
            this.meta.contentType !== DOCUMENT_DATA_FORMAT &&
            !hashes?.sha1
        ) {
            const errorMessage = `Document not of type "${DOCUMENT_DATA_FORMAT}", please supply a content ${DOCUMENT_DATA_CHECKSUM_ALGO} hash`;
            throw new Error(errorMessage);
        }

        // Calculate and set checksum
        const defaultHash = this.checksum(
            JSON.stringify(data),
            dataChecksumAlgorithm,
            DOCUMENT_DATA_ENCODING
        );

        this.hashes = {
            [dataChecksumAlgorithm]: hashes[dataChecksumAlgorithm] || defaultHash,
        };

        // Check and set document data
        if (!data) { throw new Error('Document data is a mandatory parameter'); }
        this.data = data;

        // Set version information
        this.version = version;
        this.versions = versions;
    }


    toJSON() {
        return {
            // Mandatory parameters
            schemaVersion: this.schemaVersion,
            dataChecksumAlgorithm: this.dataChecksumAlgorithm,
            id: this.id,
            type: this.type,
            version: this.version,
            hashes: this.hashes,

            // Optional parameters (will be autogenerated if missing)
            meta: this.meta,
            data: this.data,
            versions: this.versions
        }
    }

    static toJSON() {
        return {
            // Mandatory parameters
            schemaVersion: DOCUMENT_SCHEMA_VERSION,
            dataChecksumAlgorithm: DOCUMENT_DATA_CHECKSUM_ALGO,
            id: null,
            type: DOCUMENT_SCHEMA_TYPE,
            version: 1,
            hashes: {},

            // Optional parameters (will be autogenerated if missing)
            meta: {},
            data: null,
            versions: []
        }
    }

    static fromJSON(json) {
        // TODO: Fix for "undefined"
        let document = new Document({
            schemaVersion: json.schemaVersion,
            id: json.id,
            type: json.type,
            hash: json.hash,
            meta: json.meta,
            data: json.data,
            versions: json.versions
        })

        return document;
    }

    checksum(str, algorithm = DOCUMENT_DATA_CHECKSUM_ALGO, encoding = DOCUMENT_DATA_ENCODING) {
        if (typeof str === 'object') str = JSON.stringify(str)
        return crypto
            .createHash(algorithm)
            .update(str, encoding)
            .digest('hex')
    }

    static checksum(str, algorithm = DOCUMENT_DATA_CHECKSUM_ALGO, encoding = DOCUMENT_DATA_ENCODING) {
        return crypto
            .createHash(algorithm)
            .update(str, encoding)
            .digest('hex')
    }

    static validate(document) {
        if (!document) throw new Error('Document is not defined')

        // Check for mandatory parameters
        return (
            document.id &&
            document.type &&
            document.data) || false
    }

    static get schema() { return Document.toJSON(); }

    // TODO: Fix me, this is just plain wrong
    #validateHashString(str) {
        if (typeof str !== 'string') return false // throw new Error('Hash has to be of type string')
        if (!str.includes('-')) return false // throw new Error('Invalid hash format')
        return options.hash.split('-').length === 2
    }

}

module.exports = Document
