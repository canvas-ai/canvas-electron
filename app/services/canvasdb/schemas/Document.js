'use strict'

// Import necessary libraries
const crypto = require('crypto');

// Define constants
const DOCUMENT_SCHEMA_VERSION = '1.0';
const DOCUMENT_DATA_CHECKSUM_ALGO = 'sha1';
const DOCUMENT_DATA_FORMAT = 'application/json';
const DOCUMENT_DATA_ENCODING = 'utf8';
const DOCUMENT_SCHEMA_TYPE = 'document';

// Document class
class Document {

    constructor({
        id,
        type,
        version = 1,
        schemaVersion = DOCUMENT_SCHEMA_VERSION,

        meta = {},
        data,
        versions = [],

        checksum = null,
        dataChecksumAlgorithm = DOCUMENT_DATA_CHECKSUM_ALGO,
        checksumDataFields = [],
    }) {

        this.id = id;
        this.type = type;

        // Set meta information
        const now = new Date().toISOString();
        this.meta = {
            created: meta.created || now,
            modified: now,
            contentType: meta.contentType || DOCUMENT_DATA_FORMAT,
            contentEncoding: meta.contentEncoding || DOCUMENT_DATA_ENCODING,
            source: {},
            ...meta,
        };

        let checksumData;
        if (checksumDataFields.length > 0) {
            // Only include specified fields for checksum calculation
            checksumData = {};
            for (const field of checksumDataFields) {
                if (field in data) {
                    checksumData[field] = data[field];
                }
            }
        } else {
            // Include all data in checksum calculation
            checksumData = data;
        }

        // TODO: Temporary
        const defaultHash = this.createHash(
            JSON.stringify(data),
            dataChecksumAlgorithm,
            DOCUMENT_DATA_ENCODING
        );

        this.checksum = `${dataChecksumAlgorithm}/${defaultHash}`

        // Check and set document data
        if (!data) { throw new Error('Document data is a mandatory parameter'); }
        this.data = data;

        // Set version information
        this.version = version;
        this.versions = versions;
    }


    toJSON() {
        return {
            // Mandatory parameters
            schemaVersion: this.schemaVersion,

            id: this.id,
            type: this.type,
            version: this.version,

            checksum: this.checksum,
            dataChecksumAlgorithm: this.dataChecksumAlgorithm,

            // Optional parameters (will be autogenerated if missing)
            meta: this.meta,
            data: this.data,
            versions: this.versions
        }
    }

    static toJSON() {
        return {
            // Mandatory parameters
            schemaVersion: DOCUMENT_SCHEMA_VERSION,
            dataChecksumAlgorithm: DOCUMENT_DATA_CHECKSUM_ALGO,
            id: null,
            type: DOCUMENT_SCHEMA_TYPE,
            version: 1,
            checksum: null,

            // Optional parameters (will be autogenerated if missing)
            meta: {},
            data: {},
            versions: []
        }
    }

    static fromJSON(json) {
        // TODO: Fix for "undefined"
        let document = new Document({
            schemaVersion: json.schemaVersion,
            id: json.id,
            type: json.type,
            checksum: json.checksum,
            meta: json.meta,
            data: json.data,
            versions: json.versions
        })

        return document;
    }

    createHash(str, algorithm = DOCUMENT_DATA_CHECKSUM_ALGO, encoding = DOCUMENT_DATA_ENCODING) {
        if (typeof str === 'object') str = JSON.stringify(str)
        return crypto
            .createHash(algorithm)
            .update(str, encoding)
            .digest('hex')
    }

    static createHash(str, algorithm = DOCUMENT_DATA_CHECKSUM_ALGO, encoding = DOCUMENT_DATA_ENCODING) {
        return crypto
            .createHash(algorithm)
            .update(str, encoding)
            .digest('hex')
    }

    static validate(document) {
        if (!document) throw new Error('Document is not defined')

        // Check for mandatory parameters
        return (
            document.type &&
            document.data) || false
    }

    static get schema() { return Document.toJSON(); }

    // TODO: Fix me, this is just plain wrong
    #validateHashString(str) {
        if (typeof str !== 'string') return false // throw new Error('Hash has to be of type string')
        if (!str.includes('-')) return false // throw new Error('Invalid hash format')
        return options.hash.split('-').length === 2
    }

}

module.exports = Document
