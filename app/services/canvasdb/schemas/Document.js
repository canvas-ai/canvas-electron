'use strict'

// Import necessary libraries
const crypto = require('crypto');

// Define constants
const DOCUMENT_SCHEMA_VERSION = '1.0';
const DOCUMENT_SCHEMA_TYPE = 'data/abstraction/document';
const DOCUMENT_DATA_CHECKSUM_ALGO = 'sha1';
const DOCUMENT_DATA_FORMAT = 'application/json';
const DOCUMENT_DATA_ENCODING = 'utf8';

// Document class
class Document {

    constructor({
        id,
        type,
        version,
        schemaVersion,
        meta,
        data,
        dataChecksumFields,
        dataChecksumAlgorithm = DOCUMENT_DATA_CHECKSUM_ALGO,
        versions
    }) {

        this.id = id;
        this.type = type;

        this.schemaVersion = schemaVersion;

        // Set meta information
        const now = new Date().toISOString();
        this.meta = {
            created: meta.created || now,
            modified: now,
            contentType: meta.contentType || DOCUMENT_DATA_FORMAT,
            contentEncoding: meta.contentEncoding || DOCUMENT_DATA_ENCODING,
            source: {},
            ...meta,
        };

        this.checksum = this.calculateChecksum(data, dataChecksumFields);

        // TODO: Temporary
        const defaultHash = this.createHash(
            JSON.stringify(data),
            dataChecksumAlgorithm,
            DOCUMENT_DATA_ENCODING
        );

        this.checksum = `${dataChecksumAlgorithm}/${defaultHash}`

        // Check and set document data
        if (!data) { throw new Error('Document data is a mandatory parameter'); }
        this.data = data;

        // Set version information
        this.version = version;
        this.versions = versions;
    }


    toJSON() {
        return {
            // Mandatory parameters
            schemaVersion: this.schemaVersion,

            id: this.id,
            type: this.type,
            version: this.version,

            checksum: this.checksum,
            dataChecksumAlgorithm: this.dataChecksumAlgorithm,

            // Optional parameters (will be autogenerated if missing)
            meta: this.meta,
            data: this.data,
            versions: this.versions
        }
    }

    static toJSON() {
        return {
            // Mandatory parameters
            schemaVersion: DOCUMENT_SCHEMA_VERSION,
            dataChecksumAlgorithm: DOCUMENT_DATA_CHECKSUM_ALGO,
            id: null,
            type: DOCUMENT_SCHEMA_TYPE,
            version: 1,
            checksum: null,

            // Optional parameters (will be autogenerated if missing)
            meta: {},
            data: {},
            versions: []
        }
    }

    static fromJSON(json) {
        // TODO: Fix for "undefined"
        let document = new Document({
            schemaVersion: json.schemaVersion,
            id: json.id,
            type: json.type,
            checksum: json.checksum,
            meta: json.meta,
            data: json.data,
            versions: json.versions
        })

        return document;
    }

    calculateChecksum(data, fields) {
        const checksumData = fields.length ? fields.reduce((acc, field) => {
            acc[field] = data[field];
            return acc;
        }, {}) : data;

        return this.createHash(checksumData);
    }

    createHash(str, algorithm = DOCUMENT_DATA_CHECKSUM_ALGO, encoding = DOCUMENT_DATA_ENCODING) {
        if (typeof str === 'object') str = JSON.stringify(str)
        return crypto
            .createHash(algorithm)
            .update(str, encoding)
            .digest('hex')
    }

    static createHash(str, algorithm = DOCUMENT_DATA_CHECKSUM_ALGO, encoding = DOCUMENT_DATA_ENCODING) {
        return crypto
            .createHash(algorithm)
            .update(str, encoding)
            .digest('hex')
    }

    static validate(document) {
        if (!document) throw new Error('Document is not defined')

        // Check for mandatory parameters (TODO)
        return (
            document.type &&
            document.data) || false
    }

    static get schema() { return Document.toJSON(); }

    static get schemaVersion() {
        return DOCUMENT_SCHEMA_VERSION;
    }

    static get schemaType() {
        return DOCUMENT_SCHEMA_TYPE;
    }
}

module.exports = Document
